from fastapi import FastAPI, Query, HTTPException
from pydantic import BaseModel, Field
from typing import Optional
from datetime import date

app = FastAPI()

class TodoItem(BaseModel):
    title: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = None
    completed: bool = False
    due_date: Optional[date] = None

class DescriptionUpdate(BaseModel):
    description: str

todo_db = []

@app.post("/todos/")
async def create_todo(item: TodoItem):
    # Проверка уникальности title
    for todo in todo_db:
        if todo['title'].lower() == item.title.lower():
            raise HTTPException(status_code=400, detail="Todo title must be unique")

    todo_id = len(todo_db) + 1
    todo = {'id': todo_id, **item.dict()}
    todo_db.append(todo)
    return todo

@app.get("/todos/{todo_id}")
async def get_todo(todo_id: int):
    for todo in todo_db:
        if todo['id'] == todo_id:
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")

@app.put("/todos/{todo_id}")
async def update_todo(todo_id: int, item: TodoItem):
    for todo in todo_db:
        if todo['id'] == todo_id:
            todo.update(item.dict())
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")

@app.delete("/todos/{todo_id}")
async def delete_todo(todo_id: int):
    global todo_db
    todo_db = [todo for todo in todo_db if todo['id'] != todo_id]
    return {"message": "Todo item deleted successfully"}

@app.get("/todos/")
async def list_todos(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1),
    q: Optional[str] = None,
    completed: Optional[bool] = None,
    sort_by: Optional[str] = Query("id", regex="^(id|title|due_date)$")
):
    results = todo_db

    if q:
        results = [todo for todo in results if q.lower() in todo['title'].lower()]
    if completed is not None:
        results = [todo for todo in results if todo['completed'] == completed]

    # Сортировка
    if sort_by == "title":
        results.sort(key=lambda x: x['title'].lower())
    elif sort_by == "due_date":
        results.sort(key=lambda x: x.get('due_date') or date.max)
    else:
        results.sort(key=lambda x: x['id'])

    return results[skip:skip+limit]

@app.put("/todos/{todo_id}/complete")
async def mark_todo_complete(todo_id: int):
    for todo in todo_db:
        if todo['id'] == todo_id:
            todo['completed'] = True
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")

@app.patch("/todos/{todo_id}/description")
async def update_description(todo_id: int, desc: DescriptionUpdate):
    for todo in todo_db:
        if todo['id'] == todo_id:
            todo['description'] = desc.description
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")
