from fastapi import FastAPI, Query, HTTPException
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import date, datetime

app = FastAPI()

class TodoItem(BaseModel):
    title: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = None
    completed: bool = False
    due_date: Optional[datetime] = None

    @validator("due_date")
    def validate_due_date(cls, value):
        if value and value < datetime.now():
            raise ValueError("Due date must be today or in the future")
        return value

class DescriptionUpdate(BaseModel):
    description: str

todo_db = []

@app.post("/todos/")
async def create_todo(item: TodoItem):
    for todo in todo_db:
        if todo['title'].lower() == item.title.lower():
            raise HTTPException(status_code=400, detail="Todo title must be unique")

    todo_id = len(todo_db) + 1
    todo = {'id': todo_id, **item.dict()}
    todo_db.append(todo)
    return todo

@app.get("/todos/{todo_id}")
async def get_todo(todo_id: int):
    for todo in todo_db:
        if todo['id'] == todo_id:
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")

@app.put("/todos/{todo_id}")
async def update_todo(todo_id: int, item: TodoItem):
    for todo in todo_db:
        if todo['id'] == todo_id:
            todo.update(item.dict())
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")

@app.delete("/todos/{todo_id}")
async def delete_todo(todo_id: int):
    global todo_db
    todo_db = [todo for todo in todo_db if todo['id'] != todo_id]
    return {"message": "Todo item deleted successfully"}

@app.get("/todos/overdue")
async def get_overdue_todos():
    now = datetime.now()
    overdue = [
        todo for todo in todo_db
        if todo.get("due_date") and todo["due_date"] < now and not todo["completed"]
    ]
    return overdue

@app.get("/todos/")
async def list_todos(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1),
    q: Optional[str] = None,
    completed: Optional[bool] = None,
    sort_by: Optional[str] = Query("id", regex="^(id|title|due_date)$")
):
    results = todo_db

    if q:
        results = [todo for todo in results if q.lower() in todo['title'].lower()]
    if completed is not None:
        results = [todo for todo in results if todo['completed'] == completed]

    if sort_by == "title":
        results.sort(key=lambda x: x['title'].lower())
    elif sort_by == "due_date":
        results.sort(key=lambda x: x.get('due_date') or date.max)
    else:
        results.sort(key=lambda x: x['id'])

    return results[skip:skip+limit]

@app.put("/todos/{todo_id}/complete")
async def mark_todo_complete(todo_id: int):
    for todo in todo_db:
        if todo['id'] == todo_id:
            todo['completed'] = True
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")

@app.patch("/todos/{todo_id}/description")
async def update_description(todo_id: int, desc: DescriptionUpdate):
    for todo in todo_db:
        if todo['id'] == todo_id:
            todo['description'] = desc.description
            return todo
    raise HTTPException(status_code=404, detail="Todo item not found")
