from fastapi import FastAPI, Query, HTTPException
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime
from collections import Counter

app= FastAPI()
books_db = []

class Book(BaseModel):
    id: int
    title: str
    author: str
    year: int
    is_aviable: bool = True

    @validator('title')
    def title_lenght(cls, v):
        if len(v) < 3:
            raise ValueError('Title must be at least 3 characters')
        return v
    
    @validator('year')
    def valid_year(cls, v):
        current_year = datetime.now().year
        if not (1500 <= v <= current_year):
            raise ValueError(f'Year must be between 1500 and {current_year}')
        return v
    
    @app.post('/books/')
    def add_book(book: Book):
        books_db.append(book)
        return book
    
    @app.get('/books')
    def get_books(
            author: Optional[str] = None,
            is_aviable: Optional[bool] = None,
            min_year: Optional[int] = None,
            max_year: Optional[int] = None,
            skip: int = 0,
            limit: int = 10
            sort_by: Optional[str] = None,
            order: str = 'asc'
    ):

    result = books_db
    
    if author:
        result = [b for b in result if b.author == author]
    if is_aviable is not None:
        result = [b for b in result if b.is_aviable == is_aviable]
    if min_year:
        result = [b for b in result if b.year >= min_year]
    if max_year:
        result = [b for b in result if b.year <= max_year]
        
    if sort_by in {'title', 'year', 'author'}:
        reverse = order == 'desc'
        result.sort(key = lambda b: getattr(b, sort_by),reverse = reverse)

    return result[skip : skip + limit]

@app.get('/books/{book_id}')
def get_book(book_id: int):
    for book in books_db:
        if book.id == book_id:
            return book
    raise HTTPException(status_code = 404, detail = 'Book not found')

@app.put('/books/{book_id}')
def update_book(book_id: int, updated: Book):
    for i, book in enumerate(books_db):
        if book.id == book_id:
            books_db[i] = updated
            return updated
    raise HTTPException(status_code = 404, detail = 'Book not found')

@app.delete('/books/{book_id}')
def delete_book(book_id: int):
    for i, book in enumerate(books_db):
        if book.id == book_id:
            del books_db[i]
            return {'message': 'Book deleted'}
    raise HTTPException(status_code = 404, detail = 'Book not found')

@app.post('/books/bulk')
def add_books_bulk(books: List[Book]):
    books_db.extend(books)
    return {'added': len(books)}

@app.delete('/books/bulk')
def delete_books_bulk(ids: List[int] = Query())
