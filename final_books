from fastapi import FastAPI, Query, HTTPException
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime
from collections import Counter

app= FastAPI()
books_db = []

class Book(BaseModel):
    id: int
    title: str
    author: str
    year: int
    is_available: bool = True

    @validator('title')
    def title_lenght(cls, v):
        if len(v) < 3:
            raise ValueError('Title must be at least 3 characters')
        return v
    
    @validator('year')
    def valid_year(cls, v):
        current_year = datetime.now().year
        if not (1500 <= v <= current_year):
            raise ValueError(f'Year must be between 1500 and {current_year}')
        return v
    
@app.post('/books/')
def add_book(book: Book):
    books_db.append(book)
    return book
    
@app.get('/books')
def get_books(author: Optional[str] = None,
    is_available: Optional[bool] = None,
    min_year: Optional[int] = None,
    max_year: Optional[int] = None,
    skip: int = 0,
    limit: int = 10,
    sort_by: Optional[str] = None, 
    order: str = 'asc'):
    result = books_db
    if author:
        result = [b for b in result if b.author == author]
    if is_available is not None:
         result = [b for b in result if b.is_available == is_available]
    if min_year:
        result = [b for b in result if b.year >= min_year]
    if max_year:
        result = [b for b in result if b.year <= max_year]
    if sort_by in {'title', 'year', 'author'}:
        reverse = order == 'desc'
        result.sort(key = lambda b: getattr(b, sort_by), reverse = reverse)
    return result[skip : skip + limit]

@app.get('/books/search')
def search_books(q: str):
    return [b for b in books_db if q.lower() in b.title.lower() or q.lower() in b.author.lower()]

@app.get('/books/stats')
def books_stats():
    total_books = len(books_db)
    available_books = sum(b.is_available for b in books_db)
    per_author = dict(Counter(b.author for b in books_db))
    return {
        'total_books': total_books,
        'available_books': available_books,
        'books_per_author': per_author
    }

@app.get('/books/{book_id}')
def get_book(book_id: int):
    for book in books_db:
        if book.id == book_id:
            return book
    raise HTTPException(status_code = 404, detail = 'Book not found')

@app.put('/books/{book_id}')
def update_book(book_id: int, updated: Book):
    for i, book in enumerate(books_db):
        if book.id == book_id:
            books_db[i] = updated
            return updated
    raise HTTPException(status_code = 404, detail = 'Book not found')

@app.delete('/books/{book_id}')
def delete_book(book_id: int):
    for i, book in enumerate(books_db):
        if book.id == book_id:
            del books_db[i]
            return {'message': 'Book deleted'}
    raise HTTPException(status_code = 404, detail = 'Book not found')

@app.post('/books/bulk')
def add_books_bulk(books: List[Book]):
    books_db.extend(books)
    return {'added': len(books)}

@app.delete('/books/bulk')
def delete_books_bulk(ids: List[int] = Query(...)):
    initial_count = len(books_db)
    books_db[:] = [b for b in books_db if b.id not in ids]
    deleted_count = initial_count - len(books_db)
    return {'deleted': deleted_count}
